---
title: 'Inverse Probability Weighting: Anaemia'
author: "James Watson"
date: "March 20, 2019"
output: html_document
---

```{r, echo=F, include=FALSE}
knitr::opts_chunk$set(cache = TRUE, cache.comments = FALSE, 
                      echo = T, include = TRUE, 
                      fig.width = 7, fig.height = 7,
                      fig.pos = 'H', 
                      dev = c('png'), dpi = 400)

RUN_MODELS = T
library(lme4)
library(plyr); library(dplyr)
library(ipw)
library(survey)
library(boot)
library(plotrix)
library(SDMTools)
library(spatstat)

Lower_HCT = 15
Upper_HCT = 25
```

## Load dataset

```{r}
load('RData/Multiple_Imputed_Datasets.RData')
```


### Inverse probability weighting: Transfusion studies

We stratify by time to death, to remove collider bias.
Select the patients who survive past 4 hours
```{r}
load('RData/Data.RData')
#### We're just looking at the those who didn't die before 4 hours post admission
m$Outcome4hours = 0
m$Outcome4hours[!is.na(m$Timetodeathhrs) & m$Timetodeathhrs < 4] = 1
# We only look at individuals who survive past 4 hours
m = filter(m, Outcome4hours==0)

Transfusion_Data = m[m$studyID%in%c('AQUAMAT'),]
round(100*table(Transfusion_Data$transfusion)/nrow(Transfusion_Data),1)
unique_ids_Transfusion = Transfusion_Data$Unique_ID
```

```{r}
load('RData/Multiple_Imputed_Datasets.RData')
for(i in 1:length(SM_Impute_List)){
  ind = SM_Impute_List[[i]]$Unique_ID %in% unique_ids_Transfusion & 
    SM_Impute_List[[i]]$AgeInYear <= 12
  SM_Impute_List[[i]] = SM_Impute_List[[i]][ind,]
  SM_Impute_List[[i]]$country = as.character(SM_Impute_List[[i]]$country)
  SM_Impute_List[[i]]$country[SM_Impute_List[[i]]$country=='The Gambia'] = 'The_Gambia'
  SM_Impute_List[[i]]$country = as.factor(SM_Impute_List[[i]]$country)
}
```



```{r}
k = 1
par(mfrow=c(3,3))
for(cc in unique(SM_Impute_List[[k]]$country)){
  transfused = SM_Impute_List[[k]]$transfusion==1
  ind_country = SM_Impute_List[[k]]$country == cc
  
  hist(SM_Impute_List[[k]]$HCT[ind_country & transfused],
       breaks = seq(4,50, by = 1),
       col = adjustcolor('red',alpha.f = .3),
       main=cc, xlab='Haematocrit (%)', ylab = 'Number of patients')
  hist(SM_Impute_List[[k]]$HCT[ind_country & !transfused],
       breaks = 4:50,
       add=T,col=adjustcolor('blue',alpha.f = .3))
  writeLines(sprintf('The mortality in %s was %s%%', cc,
                     round(100*mean(SM_Impute_List[[k]]$outcome[ind_country]))))
}

table(SM_Impute_List[[k]]$country, SM_Impute_List[[k]]$coma)
table(SM_Impute_List[[k]]$country, SM_Impute_List[[k]]$transfusion)
```


We exclude the Congo: very low mortality and everyone gets transfused. We make a design matrix for the IPTW model
```{r}
for(i in 1:length(SM_Impute_List)){
  ind = SM_Impute_List[[i]]$country != 'Congo' & !is.na(SM_Impute_List[[i]]$rr)
  SM_Impute_List[[i]] = SM_Impute_List[[i]][ind,]
  SM_Impute_List[[i]]$country = as.factor(as.character(SM_Impute_List[[i]]$country))
}
design_matrices = list()
for(k in 1:length(SM_Impute_List)){
  XX = model.matrix(~ transfusion + country + convulsions + HCT + log2(BUN) + 
                      BD + AgeInYear + rr, 
                    data = SM_Impute_List[[k]])
  design_matrices[[k]] = as.data.frame(XX[, colnames(XX) != '(Intercept)'])
}
```


We used the time-to-death stratified data to fit a propensity score model.

We use the package *ipw* that fits standard generalised linear models (fixed effects). We also try using random forests as there is a lot of non-linearity. However this overfits massively and doesn't manage to reduce the differences between groups.


```{r}
transfusion_coefs = array(dim=c(length(SM_Impute_List),2))
transfusion_SEs = array(dim=c(length(SM_Impute_List),2))
for(k in 1:length(SM_Impute_List)){
  
  transfused = SM_Impute_List[[k]]$transfusion==1
  # using logistic regression models only
  mod_iptw_country = ipwpoint(exposure = transfusion, 
                              family = 'binomial', 
                              link = 'logit', 
                              numerator = ~ countryKenya + countryMozambique + countryNigeria + 
                                countryRwanda + countryTanzania + countryUganda + countryThe_Gambia, 
                              denominator = ~ .,
                              data = design_matrices[[k]])
  
  # same model but without country specific numerators
  mod_iptw = ipwpoint(exposure = transfusion, 
                      family = 'binomial', 
                      link = 'logit', 
                      numerator = ~ 1, 
                      denominator = ~ .,
                      data = design_matrices[[k]])
  
  # using Random forests for the denominator
  # RFmod = randomForest(x = design_matrices[[k]][, colnames(design_matrices[[k]])!='transfusion'], 
  #                      y = as.factor(design_matrices[[k]]$transfusion), 
  #                      ntree = 500,keep.forest=TRUE)
  # preds_RF_denominator = predict(RFmod, newdata = design_matrices[[k]], type = 'prob')
  # numerator_model = glm(transfusion ~ countryKenya + countryMozambique + countryNigeria + 
  #                         countryRwanda + countryTanzania + countryUganda + countryThe_Gambia, 
  #                       data = design_matrices[[k]], family = 'binomial')
  # 
  # preds_glm_numerator = predict(numerator_model, newdata = design_matrices[[k]], type = 'response')
  # 
  # SM_Impute_List[[k]]$RF_weights = NA
  # SM_Impute_List[[k]]$RF_weights[transfused] = preds_glm_numerator[transfused]/preds_RF_denominator[transfused,2]
  # SM_Impute_List[[k]]$RF_weights[!transfused] = (1-preds_glm_numerator[!transfused])/preds_RF_denominator[!transfused,1]
  # 
  SM_Impute_List[[k]]$sw = mod_iptw$ipw.weights
  SM_Impute_List[[k]]$sw_country = mod_iptw_country$ipw.weights
  
  # select those within the HCT range of interest
  analysis_ind = SM_Impute_List[[k]]$HCT <= Upper_HCT & 
    SM_Impute_List[[k]]$HCT > Lower_HCT
  
  # fit robust estimator with two different set of weights
  msm_country = (svyglm(outcome ~ transfusion, 
                        design = svydesign(~ 1, weights = ~ sw_country,
                                           data = SM_Impute_List[[k]][analysis_ind, ])))
  
  # msm_RFs = (svyglm(outcome ~ transfusion, 
  #                       design = svydesign(~ 1, weights = ~ RF_weights,
  #                                          data = SM_Impute_List[[k]][analysis_ind, ])))
  # 
  msm = (svyglm(outcome ~ transfusion, 
                design = svydesign(~ 1, weights = ~ sw,
                                   data = SM_Impute_List[[k]][analysis_ind, ])))
  
  transfusion_coefs[k,] = c(coef(msm_country)['transfusion'], 
                            coef(msm)['transfusion'])
  transfusion_SEs[k,] = c(summary(msm_country)$coefficients['transfusion','Std. Error'],
                          summary(msm)$coefficients['transfusion','Std. Error'])
}

SE_globals = c(sqrt(mean(transfusion_SEs[,1]^2) + var(transfusion_coefs[,1])),
               sqrt(mean(transfusion_SEs[,2]^2) + var(transfusion_coefs[,2])))
Coefs_global = apply(transfusion_coefs,2,mean)

writeLines(sprintf('There are %s children included in the analysis (with haematocrits between %s and %s%%)',
                   sum(analysis_ind), Lower_HCT, Upper_HCT))

writeLines(sprintf('The number of children transfused was %s, and the number not transfused was %s',
                   table(SM_Impute_List[[k]]$transfusion[analysis_ind])[1],
                   table(SM_Impute_List[[k]]$transfusion[analysis_ind])[2]))

writeLines(sprintf('The odds ratio for death for the transfused versus not transfused, in children with baseline haematocrit between %s and %s%%, is estimated to be %s (%s-%s)',
                   Lower_HCT, Upper_HCT, round(exp(Coefs_global[2]),2), 
                   round(exp(Coefs_global[2]-1.96*SE_globals[2]),2),
                   round(exp(Coefs_global[2]+1.96*SE_globals[2]),2)))
```

Lets examine the weights in one of the fits
```{r}
par(las=1, mfrow=c(2,1))
k = sample(1:length(SM_Impute_List),1)
plot(SM_Impute_List[[k]]$HCT, log10(mod_iptw$ipw.weights),
     col=SM_Impute_List[[k]]$transfusion+1, xlab = 'Haematocrit', 
     ylab = 'log 10 weight', main = 'Stabilised: marginal probability')
abline(v = c(Lower_HCT, Upper_HCT), lty=2, lwd=2)

plot(SM_Impute_List[[k]]$HCT, log10(mod_iptw_country$ipw.weights),
     col=SM_Impute_List[[k]]$transfusion+1, xlab = 'Haematocrit', 
     ylab = 'log 10 weight', main = 'Stabilised: country marginal probability')
abline(v = c(Lower_HCT, Upper_HCT), lty=2, lwd=2)
summary(mod_iptw_country$num.mod)
summary(mod_iptw$den.mod)
```

Set the lower and upper limits of HCT for the transfusion IPW analysis and remove data outside the interval of interest:
```{r}
Mod_SM_Impute_List = SM_Impute_List
for(k in 1:length(SM_Impute_List)){
  analysis_ind = SM_Impute_List[[k]]$HCT <= Upper_HCT & 
    SM_Impute_List[[k]]$HCT > Lower_HCT
  Mod_SM_Impute_List[[k]] = SM_Impute_List[[k]][analysis_ind,]
}
```




```{r}
standardised_diff_binary = function(x, t, ws){
  
  ind = complete.cases(x)
  x=x[ind]
  t=t[ind]
  ws=ws[ind]
  
  mu_treat = mean(x[t])
  mu_untreat = mean(x[!t])
  std_diff = 100 * (mu_treat - mu_untreat)/sqrt(((1-mu_treat)*mu_treat + mu_untreat*(1-mu_untreat))/2)
  
  mu_treat = weighted.mean(x[t],w = ws[t])
  mu_untreat = weighted.mean(x[!t], w = ws[!t])
  
  var_treat = wt.var(x = x[t], wt = ws[t])
  var_untreat = wt.var(x = x[!t], wt = ws[!t])
  std_diff_weighted = 100 * (mu_treat - mu_untreat)/sqrt((var_treat + var_untreat)/2)
  return(list(std_diff=std_diff, std_diff_weighted=std_diff_weighted))
}

standardised_diff_cont = function(x, t, ws){
  
  ind = complete.cases(x)
  x=x[ind]
  t=t[ind]
  ws=ws[ind]
  
  
  mu_treat = mean(x[t])
  mu_untreat = mean(x[!t])
  var_treat = var(x = x[t])
  var_untreat = var(x = x[!t])
  
  std_diff = 100 * (mu_treat - mu_untreat)/sqrt((var_treat + var_untreat)/2)
  
  mu_treat = weighted.mean(x[t],w = ws[t])
  mu_untreat = weighted.mean(x[!t], w = ws[!t])
  var_treat = wt.var(x = x[t], wt = ws[t])
  var_untreat = wt.var(x = x[!t], wt = ws[!t])
  
  std_diff_weighted = 100 * (mu_treat - mu_untreat)/sqrt((var_treat + var_untreat)/2)
  return(list(std_diff=std_diff, std_diff_weighted=std_diff_weighted))
}
```


```{r ecdf_plots_IPTW}
par(mfrow=c(4,2))
k=1
transfused = Mod_SM_Impute_List[[k]]$transfusion==1
ws = Mod_SM_Impute_List[[k]]$sw
diffs = list()


#Haematocrit
plot(ecdf((Mod_SM_Impute_List[[k]]$HCT[transfused])),col =adjustcolor('red',alpha.f = .7),main='',xlab='Haematocrit', ylab = 'Proportion < x')
lines(ecdf((Mod_SM_Impute_List[[k]]$HCT[!transfused])),col =adjustcolor('blue',alpha.f = .7))

plot(ewcdf((Mod_SM_Impute_List[[k]]$HCT[transfused]),weights = ws),col =adjustcolor('red',alpha.f = .7),main='',xlab='Haematocrit', ylab = 'Proportion < x')
lines(ewcdf((Mod_SM_Impute_List[[k]]$HCT[!transfused]),weights = ws),col =adjustcolor('blue',alpha.f = .7))

x=standardised_diff_cont(x = Mod_SM_Impute_List[[k]]$HCT, 
                         t = transfused,
                         ws = Mod_SM_Impute_List[[k]]$sw)

diffs[[1]] = list(Haematocrit = x)
# Base deficit
plot(ecdf((Mod_SM_Impute_List[[k]]$BD[transfused])),col =adjustcolor('red',alpha.f = .7),
     main='',xlab='Base deficit', ylab = 'Proportion < x')
lines(ecdf((Mod_SM_Impute_List[[k]]$BD[!transfused])),col =adjustcolor('blue',alpha.f = .7))

plot(ewcdf((Mod_SM_Impute_List[[k]]$BD[transfused]),weights = ws),
     col =adjustcolor('red',alpha.f = .7),main='',xlab='Base deficit', ylab = 'Proportion < x')
lines(ewcdf((Mod_SM_Impute_List[[k]]$BD[!transfused]),weights = ws),col =adjustcolor('blue',alpha.f = .7))


x=standardised_diff_cont(x = Mod_SM_Impute_List[[k]]$BD, 
                         t = transfused,
                         ws = Mod_SM_Impute_List[[k]]$sw_country)
diffs[[2]] = list(BaseDeficit = x)

# BUN 
plot(ecdf(log(Mod_SM_Impute_List[[k]]$BUN[transfused])),col =adjustcolor('red',alpha.f = .7),
     main='',xlab='Log blood urea nitrogen', ylab = 'Proportion < x')
lines(ecdf(log(Mod_SM_Impute_List[[k]]$BUN[!transfused])),col =adjustcolor('blue',alpha.f = .7))

plot(ewcdf(log(Mod_SM_Impute_List[[k]]$BUN[transfused]),weights = ws),
     col =adjustcolor('red',alpha.f = .7),main='',xlab='Log blood urea nitrogen', ylab = 'Proportion < x')
lines(ewcdf(log(Mod_SM_Impute_List[[k]]$BUN[!transfused]),weights = ws),
      col =adjustcolor('blue',alpha.f = .7))
x=standardised_diff_cont(x = log(Mod_SM_Impute_List[[k]]$BUN), 
                         t = transfused,
                         ws = ws)
diffs[[3]] = list(BUN = x)

# Hypoglycaemia
x=standardised_diff_binary(x = Mod_SM_Impute_List[[k]]$hypoglycaemia, 
                           t = transfused,
                           ws = ws)
diffs[[4]] = list(Hypoglycaemia = x)


# Coma
x=standardised_diff_binary(x = Mod_SM_Impute_List[[k]]$coma, 
                           t = transfused,
                           ws = ws)
diffs[[5]] = list(Coma = x)

# Shock
x=standardised_diff_binary(x = as.numeric(as.character(Mod_SM_Impute_List[[k]]$shock)), 
                           t = transfused,
                           ws = ws)
diffs[[6]] = list(Shock = x)

# Convulsions
x=standardised_diff_binary(x = as.numeric(as.character(Mod_SM_Impute_List[[k]]$convulsions)), 
                           t = transfused,
                           ws = ws)

diffs[[7]] = list(Convulsions = x)


# PO
x= standardised_diff_binary(x = as.numeric(as.character(Mod_SM_Impute_List[[k]]$poedema)), 
                            t = transfused,
                            ws = ws)
diffs[[8]] = list(PulmonaryOedema = x)

# Respiratory rate
plot(ecdf(round(Mod_SM_Impute_List[[k]]$rr[transfused])),
     col =adjustcolor('red',alpha.f = .7),
     main='',xlab='Respiratory rate', ylab = 'Proportion < x')
lines(ecdf(round(Mod_SM_Impute_List[[k]]$rr[!transfused])),col =adjustcolor('blue',alpha.f = .7))

plot(ewcdf(round(Mod_SM_Impute_List[[k]]$rr[transfused]),weights = ws),
     col =adjustcolor('red',alpha.f = .7),main='',
     xlab='Respiratory rate', ylab = 'Proportion < x')
lines(ewcdf(round(Mod_SM_Impute_List[[k]]$rr[!transfused]),weights = ws),
      col =adjustcolor('blue',alpha.f = .7))
x = standardised_diff_cont(x = Mod_SM_Impute_List[[k]]$rr, 
                           t = transfused,
                           ws = ws)
diffs[[9]] = list(RespRate = x)

```


```{r}
Mydiffs = array(dim = c(length(diffs), 2))
names(diffs)
rownames(Mydiffs) = unlist(lapply(diffs, names))
diffs = lapply(diffs, unlist)
for(i in 1:nrow(Mydiffs)){
  Mydiffs[i, ] = diffs[[i]]
}
# Mydiffs = abs(Mydiffs)
Mydiffs = Mydiffs[order(Mydiffs[,1]), ]
Mydiffs
```


```{r standardised_diff}
par(las=1, mar=c(4,7,2,2))
plot(Mydiffs[,1], 1:nrow(Mydiffs), xlim = range(Mydiffs), yaxt='n', ylab = '',
     pch = 16, xlab = 'Standardised difference (%)')
abline(v = c(-10,10), lty=2)
abline(v=0)

points(Mydiffs[,2], 1:nrow(Mydiffs), col ='red', pch =17)

row_names = mapvalues(x = rownames(Mydiffs),  
                      from = c('PulmonaryOedema', 'BaseDeficit', 'RespRate','BUN'),
                      to = c('Pulmonary\nOedema', 'Base\nDeficit', 'Respiratory\nRate','Blood Urea\nNitrogen'))
axis(2, at = 1:nrow(Mydiffs), labels = row_names)
legend('topleft', inset = 0.02, pch = c(16,17), col=c('black','red'),
       legend = c('Original population','IPW population'))
```

